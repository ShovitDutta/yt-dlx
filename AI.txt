THE ISSUE:
As you can see the code is properly getting the data but the output is empty.
For debug i tried console.log(result) in the code itself and it does show the result.
That means the emitter is not getting the data maybe?
Please check and fix


THE CODE:
import colors from "colors";
import { z, ZodError } from "zod";
import { EventEmitter } from "events";
import TubeResponse from "../../interfaces/TubeResponse";
import TubeLogin, { TubeType } from "../../utils/TubeLogin";
import sanitizeContentItem from "../../utils/sanitizeContentItem";
const ZodSchema = z.object({
  cookies: z.string(),
  verbose: z.boolean().optional(),
  sort: z.enum(["oldest", "newest", "old-to-new", "new-to-old"]).optional(),
});
/**
 * Fetches the home feed for the user based on the provided parameters.
 *
 * @param {Object} options - The options for fetching the home feed.
 * @param {string} options.cookies - YouTube authentication cookies string or path to cookies file.
 * @param {boolean} [options.verbose] - Flag to enable verbose output. Optional.
 * @param {"oldest" | "newest" | "old-to-new" | "new-to-old"} [options.sort] - The sorting order for the feed. Optional.
 *
 * @returns {EventEmitter} An EventEmitter object that emits the following events:
 * - "data": Contains the fetched home feed data.
 * - "error": Emits an error message if the fetching fails.
 *
 * @example
 * // Example 1: Fetch home feed with cookies string
 * await YouTubeDLX.Account.HomeFeed({ cookies: "COOKIE_STRING" })
 *   .on("data", (feed) => console.log("Home feed:", feed))
 *   .on("error", (err) => console.error("Error:", err));
 *
 * @example
 * // Example 2: Fetch home feed with path to cookies file
 * await YouTubeDLX.Account.HomeFeed({ cookies: "path/to/cookies.txt" })
 *   .on("data", (feed) => console.log("Home feed:", feed))
 *   .on("error", (err) => console.error("Error:", err));
 */
export default async function home_feed(options: z.infer<typeof ZodSchema>): Promise<EventEmitter<[never]>> {
  const emitter = new EventEmitter();
  return new Promise(async (resolve, reject) => {
    try {
      ZodSchema.parse(options);
      const { verbose, cookies, sort } = options;
      if (verbose) console.log(colors.green("@info:"), "Fetching home feed...");
      if (!cookies) {
        emitter.emit("error", `${colors.red("@error:")} cookies not provided!`);
        return;
      }
      const client: TubeType = await TubeLogin(cookies);
      const homeFeed = await client.getHomeFeed();
      const result: TubeResponse<{ Shorts: any[]; Videos: any[] }> = { status: "success", data: { Shorts: [], Videos: [] } };
      homeFeed.contents?.contents?.forEach((section: any) => {
        if (section.type === "RichItem" && section.content?.type === "Video") {
          const sanitized = sanitizeContentItem(section);
          result.data?.Videos.push({
            type: sanitized?.content?.type || "",
            title: sanitized?.content?.title?.text || "",
            videoId: sanitized?.content?.video_id || "",
            description: sanitized?.content?.description_snippet?.text || "",
            thumbnails: sanitized?.content?.thumbnails || [],
            authorId: sanitized?.content?.author?.id || "",
            authorName: sanitized?.content?.author?.name || "",
            authorThumbnails: sanitized?.content?.author?.thumbnails || [],
            authorBadges: sanitized?.content?.author?.badges || [],
            authorUrl: sanitized?.content?.author?.url || "",
            viewCount: sanitized?.content?.view_count?.text || "",
            shortViewCount: sanitized?.content?.short_view_count?.text || "",
          });
        } else if (section.type === "RichSection" && section.content?.type === "RichShelf") {
          section.content.contents?.forEach((item: any) => {
            if (item.content?.type === "ShortsLockupView") {
              const short = { title: item?.content?.accessibility_text || "", videoId: item?.content?.on_tap_endpoint?.payload?.videoId, thumbnails: item?.content?.thumbnail || [] };
              result.data?.Shorts.push(short);
            }
          });
        }
      });
      switch (sort) {
        case "oldest":
          result.data?.Shorts.splice(0, result.data?.Shorts.length - 1);
          result.data?.Videos.splice(0, result.data?.Videos.length - 1);
          break;
        case "newest":
          result.data?.Shorts.splice(1);
          result.data?.Videos.splice(1);
          break;
        case "old-to-new":
          result.data?.Shorts.sort((a, b) => a.videoId.localeCompare(b.videoId));
          result.data?.Videos.sort((a, b) => a.videoId.localeCompare(b.videoId));
          break;
        case "new-to-old":
          result.data?.Shorts.sort((a, b) => b.videoId.localeCompare(a.videoId));
          result.data?.Videos.sort((a, b) => b.videoId.localeCompare(b.videoId));
          break;
      }
      if (verbose) console.log(colors.green("@info:"), "Home feed fetched!");
      emitter.emit("data", result);
      resolve(emitter);
    } catch (error) {
      if (error instanceof ZodError) emitter.emit("error", error.errors);
      else if (error instanceof Error) emitter.emit("error", error.message);
      else emitter.emit("error", String(error));
      reject(error);
    } finally {
      console.log(colors.green("@info:"), "‚ù£Ô∏è Thank you for using yt-dlx. Consider üåüstarring the GitHub repo https://github.com/yt-dlx.");
    }
  });
}

THE TEST:
import { env } from "node:process";
import dotenv from "dotenv";
import colors from "colors";
import YouTubeDLX from "..";
console.clear();
dotenv.config();
(async () => {
  console.log(colors.bold.blue("@info"), "Test For HomeFeed: (1): Fetch home feed with only the cookies");
  var emitter = await YouTubeDLX.Account.HomeFeed({ cookies: env.cookies as string });
  emitter.on("data", data => console.log(colors.italic.green("@data:"), data));
  emitter.on("error", error => console.error(colors.italic.red("@error:"), error));
  console.log(colors.bold.blue("@info"), "Test For HomeFeed: (2): Fetch home feed with cookies and verbose output enabled");
  var emitter = await YouTubeDLX.Account.HomeFeed({ cookies: env.cookies as string, verbose: true });
  emitter.on("data", data => console.log(colors.italic.green("@data:"), data));
  emitter.on("error", error => console.error(colors.italic.red("@error:"), error));
  console.log(colors.bold.blue("@info"), "Test For HomeFeed: (3): Fetch home feed with cookies and sorting by 'oldest'");
  var emitter = await YouTubeDLX.Account.HomeFeed({ cookies: env.cookies as string, sort: "oldest" });
  emitter.on("data", data => console.log(colors.italic.green("@data:"), data));
  emitter.on("error", error => console.error(colors.italic.red("@error:"), error));
  console.log(colors.bold.blue("@info"), "Test For HomeFeed: (4): Fetch home feed with cookies and sorting by 'newest'");
  var emitter = await YouTubeDLX.Account.HomeFeed({ cookies: env.cookies as string, sort: "newest" });
  emitter.on("data", data => console.log(colors.italic.green("@data:"), data));
  emitter.on("error", error => console.error(colors.italic.red("@error:"), error));
  console.log(colors.bold.blue("@info"), "Test For HomeFeed: (5): Fetch home feed with cookies and sorting by 'old-to-new'");
  var emitter = await YouTubeDLX.Account.HomeFeed({ cookies: env.cookies as string, sort: "old-to-new" });
  emitter.on("data", data => console.log(colors.italic.green("@data:"), data));
  emitter.on("error", error => console.error(colors.italic.red("@error:"), error));
  console.log(colors.bold.blue("@info"), "Test For HomeFeed: (6): Fetch home feed with cookies and sorting by 'new-to-old'");
  var emitter = await YouTubeDLX.Account.HomeFeed({ cookies: env.cookies as string, sort: "new-to-old" });
  emitter.on("data", data => console.log(colors.italic.green("@data:"), data));
  emitter.on("error", error => console.error(colors.italic.red("@error:"), error));
  console.log(colors.bold.blue("@info"), "Test For HomeFeed: (7): Fetch home feed with all parameters (cookies: env.cookies as string, verbose, and sort)");
  var emitter = await YouTubeDLX.Account.HomeFeed({ cookies: env.cookies as string, verbose: true, sort: "new-to-old" });
  emitter.on("data", data => console.log(colors.italic.green("@data:"), data));
  emitter.on("error", error => console.error(colors.italic.red("@error:"), error));
})();


THE OUTPUT:
@info Test For HomeFeed: (1): Fetch home feed with only the cookies
@info: Connected to YouTube...
@info: ‚ù£Ô∏è Thank you for using yt-dlx. Consider üåüstarring the GitHub repo https://github.com/yt-dlx.
@info Test For HomeFeed: (2): Fetch home feed with cookies and verbose output enabled
@info: Fetching home feed...
@info: Connected to YouTube...
@info: Home feed fetched!
@info: ‚ù£Ô∏è Thank you for using yt-dlx. Consider üåüstarring the GitHub repo https://github.com/yt-dlx.
@info Test For HomeFeed: (3): Fetch home feed with cookies and sorting by 'oldest'
@info: Connected to YouTube...
@info: ‚ù£Ô∏è Thank you for using yt-dlx. Consider üåüstarring the GitHub repo https://github.com/yt-dlx.
@info Test For HomeFeed: (4): Fetch home feed with cookies and sorting by 'newest'
@info: Connected to YouTube...
@info: ‚ù£Ô∏è Thank you for using yt-dlx. Consider üåüstarring the GitHub repo https://github.com/yt-dlx.
@info Test For HomeFeed: (5): Fetch home feed with cookies and sorting by 'old-to-new'
@info: Connected to YouTube...
@info: ‚ù£Ô∏è Thank you for using yt-dlx. Consider üåüstarring the GitHub repo https://github.com/yt-dlx.
@info Test For HomeFeed: (6): Fetch home feed with cookies and sorting by 'new-to-old'
@info: Connected to YouTube...
@info: ‚ù£Ô∏è Thank you for using yt-dlx. Consider üåüstarring the GitHub repo https://github.com/yt-dlx.
@info Test For HomeFeed: (7): Fetch home feed with all parameters (cookies: env.cookies as string, verbose, and sort)
@info: Fetching home feed...
@info: Connected to YouTube...
@info: Home feed fetched!
@info: ‚ù£Ô∏è Thank you for using yt-dlx. Consider üåüstarring the GitHub repo https://github.com/yt-dlx.