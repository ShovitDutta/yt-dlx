# code 1: main.py
import os
import sys
import subprocess
def find_venv_python():
    if getattr(sys, "frozen", False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    if sys.platform == "win32":
        venv_python_path = os.path.join(base_path, "context", "windows", "venv", "python.exe")
    else:
        venv_python_path = os.path.join(base_path, "context", "linux", "venv", "bin", "python")
    if os.path.exists(venv_python_path):
        return venv_python_path
    else:
        return None
if __name__ == "__main__":
    venv_python = find_venv_python()
    app_script_name = "logic.py"
    app_script_path = os.path.join(sys._MEIPASS if getattr(sys, "frozen", False) else os.path.dirname(os.path.abspath(__file__)), app_script_name)
    if venv_python and os.path.exists(app_script_path):
        command = [venv_python, app_script_path] + sys.argv[1:]
        try:
            result = subprocess.run(command, check=False)
            sys.exit(result.returncode)
        except FileNotFoundError:
            print(f"Error: The bundled Python executable was not found at \"{venv_python}\" or the script \"{app_script_path}\" was not found.", file=sys.stderr)
            sys.exit(1)
        except PermissionError:
            print(f"Error: Permission denied to execute the bundled Python executable at \"{venv_python}\".", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"An unexpected error occurred while launching logic.py: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        if not venv_python:
            print("Error: Venv Python interpreter not found in the bundled environment.", file=sys.stderr)
            print(f"Expected to find it at: {os.path.join(sys._MEIPASS if getattr(sys, 'frozen', False) else os.path.dirname(os.path.abspath(__file__)), 'context', 'windows', 'venv', 'python.exe')}", file=sys.stderr)
        if not os.path.exists(app_script_path):
            print(f"Error: Application logic script \"{app_script_path}\" not found in the bundled environment.", file=sys.stderr)
        sys.exit(1)

# code 2: logic.py
import os
import re
import sys
import json
import argparse
import subprocess

def find_bundled_file(relative_bundle_path):
    if getattr(sys, "frozen", False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    file_path = os.path.join(base_path, relative_bundle_path.replace("/", os.sep))
    if not getattr(sys, "frozen", False) and not os.path.exists(file_path):
        alt_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "..", "..", "..", relative_bundle_path.replace("/", os.sep))
        if os.path.exists(alt_path):
            file_path = alt_path
        else:
            return None
    if os.path.exists(file_path):
        return file_path
    else:
        return None

def run_executable(executable_name_without_ext, executable_path, args):
    if not executable_path:
        print(f"Error: {executable_name_without_ext} not found in bundle.", file=sys.stderr)
        sys.exit(1)
    command = [executable_path] + args
    is_ytprobe = executable_name_without_ext == "ytprobe"
    try:
        if is_ytprobe:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                check=False
            )
            modified_stdout = re.sub(r"yt-dlp", "yt-dlx", result.stdout, flags=re.IGNORECASE)
            modified_stderr = re.sub(r"yt-dlp", "yt-dlx", result.stderr, flags=re.IGNORECASE)
            sys.stdout.write(modified_stdout)
            sys.stderr.write(modified_stderr)
            sys.exit(result.returncode)
        else:
            result = subprocess.run(
                command,
                stdout=None,
                stderr=None,
                check=False
            )
            sys.exit(result.returncode)
    except FileNotFoundError:
        print(f"Error: The executable \"{command[0]}\" was not found. Make sure the file \"{executable_path}\" exists in the bundle.", file=sys.stderr)
        sys.exit(127)
    except PermissionError:
        print(f"Error: Permission denied to execute \"{command[0]}\".", file=sys.stderr)
        sys.exit(126)
    except subprocess.SubprocessError as e:
        print(f"Error running command \"{' '.join(command)}\": {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred while running \"{' '.join(command)}\": {e}", file=sys.stderr)
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser(description="yt-dlx: YouTube downloader utility with bundled executables")
    parser.add_argument("--ffprobe", nargs=argparse.REMAINDER, help="Run ffprobe with the arguments...")
    parser.add_argument("--ytprobe", nargs=argparse.REMAINDER, help="Run ytprobe with the arguments...")
    parser.add_argument("--ffmpeg", nargs=argparse.REMAINDER, help="Run ffmpeg with the arguments...")
    parser.add_argument("--tor", nargs=argparse.REMAINDER, help="Run tor with the arguments...")
    args = parser.parse_args()
    if sys.platform == "win32":
        tor_path = find_bundled_file("context/windows/TorBrowser/tor/tor.exe")
        tor_data_dir = find_bundled_file("context/windows/TorBrowser/data")
        ytprobe_path = find_bundled_file("context/windows/ytprobe.exe")
        ffprobe_path = find_bundled_file("context/windows/ffprobe.exe")
        ffmpeg_path = find_bundled_file("context/windows/ffmpeg.exe")
    else:
        ffmpeg_path = find_bundled_file("context/linux/ffmpeg.bin")
        ytprobe_path = find_bundled_file("context/linux/ytprobe.bin")
        ffprobe_path = find_bundled_file("context/linux/ffprobe.bin")
        tor_path = find_bundled_file("context/linux/TorBrowser/tor/tor")
        tor_data_dir = find_bundled_file("context/linux/TorBrowser/data")
    if args.tor is not None:
        if not tor_path:
            print("Error: Bundled Tor executable not found in expected location.", file=sys.stderr)
            sys.exit(1)
        if not tor_data_dir:
            print("Error: Bundled Tor Data directory not found in expected location.", file=sys.stderr)
            sys.exit(1)
        tor_subprocess_args = []
        tor_subprocess_args.extend(["--DataDirectory", tor_data_dir])
        bundled_torrc_filename = "torrc"
        bundled_torrc_full_path = os.path.join(tor_data_dir, bundled_torrc_filename)
        if os.path.exists(bundled_torrc_full_path):
            tor_subprocess_args.extend(["--config-file", bundled_torrc_full_path])
        else:
            print(f"Warning: Bundled torrc not found at expected location: {bundled_torrc_full_path}", file=sys.stderr)
        tor_subprocess_args.extend(args.tor)
        run_executable("tor", tor_path, tor_subprocess_args)
    elif args.ytprobe is not None:
        run_executable("ytprobe", ytprobe_path, args.ytprobe)
    elif args.ffmpeg is not None:
        run_executable("ffmpeg", ffmpeg_path, args.ffmpeg)
    elif args.ffprobe is not None:
        run_executable("ffprobe", ffprobe_path, args.ffprobe)
    else:
        paths_info = {
            "Running Python Executable": sys.executable,
            "ffmpeg": ffmpeg_path if ffmpeg_path else "Not found in bundle",
            "tor_executable": tor_path if tor_path else "Not found in bundle",
            "ffprobe": ffprobe_path if ffprobe_path else "Not found in bundle",
            "ytprobe": ytprobe_path if ytprobe_path else "Not found in bundle",
            "tor_data_directory": tor_data_dir if tor_data_dir else "Not found in bundle",
            "bundled_torrc_win": find_bundled_file("context/windows/TorBrowser/data/torrc") if sys.platform == "win32" else "N/A on this platform",
            "bundled_torrc_linux": find_bundled_file("context/linux/TorBrowser/data/torrc") if sys.platform != "win32" else "N/A on this platform",
        }
        print(json.dumps(paths_info, indent=2))

if __name__ == "__main__":
    main()

# code 3: repack.py
import os
import sys
import shutil
import subprocess
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)
command = [sys.executable, "-m", "PyInstaller", "--onefile", "--icon", "context/logo.jpg", "main.py", "--add-data", "logic.py:."]
if sys.platform == "win32":
    command.extend([
        "--name", "yt-dlx.exe",
        "--add-data", "context/windows/TorBrowser:context/windows/TorBrowser",
        "--add-binary", "context/windows/ytprobe.exe:context/windows/",
        "--add-binary", "context/windows/ffprobe.exe:context/windows/",
        "--add-binary", "context/windows/ffmpeg.exe:context/windows/",
        "--add-data", "context/windows/venv:context/windows/venv",
    ])
    exe_name = "yt-dlx.exe"
elif sys.platform.startswith("linux"):
    command.extend([
        "--name", "yt-dlx.bin",
        "--add-data", "context/linux/venv:context/linux/venv",
        "--add-binary", "context/linux/ffmpeg.bin:context/linux/",
        "--add-binary", "context/linux/ffprobe.bin:context/linux/",
        "--add-binary", "context/linux/ytprobe.bin:context/linux/",
        "--add-data", "context/linux/TorBrowser:context/linux/TorBrowser",
    ])
    exe_name = "yt-dlx.bin"
else:
    print(f"Unsupported platform: {sys.platform}", file=sys.stderr)
    sys.exit(1)
print("Running PyInstaller command:")
print(" ".join(command))
try:
    subprocess.run(command, check=True)
    source_exe_path = os.path.join(script_dir, "dist", exe_name)
    dest_exe_path = os.path.join(script_dir, exe_name)
    if os.path.exists(source_exe_path):
        if os.path.exists(dest_exe_path):
            os.remove(dest_exe_path)
        shutil.move(source_exe_path, dest_exe_path)
        print(f"Successfully created and moved {exe_name} to {dest_exe_path}")
    else:
        print(f"Error: Expected executable not found at {source_exe_path}", file=sys.stderr)
        sys.exit(1)
except subprocess.CalledProcessError as e:
    print(f"PyInstaller failed with exit code {e.returncode}", file=sys.stderr)
    sys.exit(e.returncode)
except Exception as e:
    print(f"An unexpected error occurred during repackaging: {e}", file=sys.stderr)
    sys.exit(1)
finally:
    spec_file = os.path.join(script_dir, f"{exe_name}.spec")
    build_folder = os.path.join(script_dir, "build")
    dist_folder_partial = os.path.join(script_dir, "dist")
    if os.path.exists(spec_file):
        print(f"Cleaning up {spec_file}")
        os.remove(spec_file)
    if os.path.exists(build_folder):
        print(f"Cleaning up {build_folder}")
        shutil.rmtree(build_folder)
    if os.path.exists(dist_folder_partial) and not os.listdir(dist_folder_partial):
        print(f"Cleaning up empty {dist_folder_partial}")
        shutil.rmtree(dist_folder_partial)

